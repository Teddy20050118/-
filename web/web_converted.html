<!doctype html>
<html lang="zh-TW">

<head>
  <meta charset="utf-8" />
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover" />
  <title>é»é¤åŠ©æ‰‹</title>
  <link rel="stylesheet" href="/web/web.css?v=20260127-responsive" />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet" />
</head>

<body>
  <div class="app-shell">
    <aside class="sidebar">
      <div class="sidebar-brand">
        <div class="logo-chip">é»é¤åŠ©æ‰‹</div>
      </div>

      <!-- é¤å»³é¸æ“‡å™¨ -->
      <div class="restaurant-selector">
        <label class="restaurant-label">
          é¸æ“‡é¤å»³
        </label>
        <div style="display: flex; gap: 8px; align-items: center;">
          <select id="restaurant-select" class="restaurant-select" style="flex: 1;">
            <option>è¼‰å…¥ä¸­...</option>
          </select>
          <button id="delete-restaurant-btn" class="ghost-btn" type="button" title="åˆªé™¤ç•¶å‰é¤å»³"
            style="color: #dc2626; flex-shrink: 0;">ğŸ—‘ï¸</button>
        </div>
        <div id="restaurant-info" class="restaurant-info">
          ç­‰å¾…è¼‰å…¥é¤å»³è³‡è¨Š...
        </div>
      </div>

      <div class="sidebar-actions">
        <button id="new-chat-btn" class="action-btn primary" type="button">ï¼‹ æ–°å°è©±</button>
      </div>
      <div class="sidebar-chats" aria-label="å°è©±åˆ—è¡¨">
        <div class="chat-search">
          <input id="chat-search" type="text" placeholder="æœå°‹å°è©±â€¦" autocomplete="off" />
        </div>
        <div class="chat-tools">
          <button id="export-all-btn" class="ghost-btn" type="button">åŒ¯å‡º</button>
          <button id="import-json-btn" class="ghost-btn" type="button">åŒ¯å…¥</button>
          <input id="import-file" type="file" accept="application/json" hidden />
        </div>
        <div id="chat-list" class="chat-list"></div>
      </div>
      <div class="sidebar-meta">
        <div>æç¤ºï¼šå³éµæˆ– â‹¯ å¯æ‰“é–‹é¸å–®</div>
        <div>æ‰‹æ©Ÿï¼šå¾€ä¸‹æ»‘çœ‹è¼¸å…¥æ¡†</div>
      </div>
    </aside>

    <main class="chat-panel">
      <header class="chat-header">
        <div class="header-left">
          <p class="chat-title">é»é¤åŠ©æ‰‹</p>
          <!-- æ‰‹æ©Ÿç‰ˆé¤å»³é¸æ“‡å™¨ -->
          <select id="restaurant-select-mobile" class="restaurant-select-mobile">
            <option>è¼‰å…¥ä¸­...</option>
          </select>
        </div>
        <div class="header-actions">
          <div class="header-actions-left">
            <button id="theme-toggle-btn" class="ghost-btn" type="button" title="åˆ‡æ›æ·±è‰²æ¨¡å¼">
              <span id="theme-icon">æ·±è‰²æ¨¡å¼</span>
            </button>
            <button id="clear-btn" class="ghost-btn" type="button">æ¸…ç©ºå°è©±</button>
            <button id="help-btn" class="ghost-btn" type="button">ä½¿ç”¨èªªæ˜</button>
          </div>
          <div class="header-actions-right">
            <button id="view-menu-btn" class="ghost-btn" type="button" title="æŸ¥çœ‹å®Œæ•´èœå–®">æŸ¥çœ‹èœå–®</button>
            <button id="crawl-btn" class="ghost-btn" type="button" title="çˆ¬å–æ–°é¤å»³èœå–®">çˆ¬èœå–®</button>
          </div>
        </div>
      </header>

      <section class="chat-body">
        <div class="chat-bar"></div>

        <div id="chat-box" class="conversation" aria-live="polite"></div>

        <div id="loading" class="message bot hidden">
          <div class="avatar">AI</div>
          <div class="bubble loading">
            <span class="dot"></span><span class="dot"></span><span class="dot"></span>
          </div>
        </div>
      </section>

      <footer class="chat-footer">
        <div class="input-area">
          <div class="input-wrapper">
            <textarea id="input" class="chat-input" placeholder="è¼¸å…¥è¨Šæ¯â€¦" rows="1"></textarea>
            <button id="send-btn" class="send-btn" type="button">é€å‡º</button>
          </div>
        </div>
      </footer>
    </main>
  </div>

  <div id="chat-menu" class="chat-menu hidden" role="menu">
    <button class="chat-menu-item" type="button" data-action="rename">é‡æ–°å‘½å</button>
    <button class="chat-menu-item" type="button" data-action="pin">é‡˜é¸ / å–æ¶ˆé‡˜é¸</button>
    <button class="chat-menu-item" type="button" data-action="export">åŒ¯å‡ºæ­¤å°è©±</button>
    <div class="chat-menu-sep"></div>
    <button class="chat-menu-item danger" type="button" data-action="delete">åˆªé™¤</button>
  </div>

  <div id="toast-host" class="toast-host"></div>

  <!-- å®Œæ•´èœå–® Modal -->
  <div id="menu-modal" class="menu-modal hidden">
    <div class="menu-modal-overlay"></div>
    <div class="menu-modal-content">
      <div class="menu-modal-header">
        <h2 id="menu-modal-title" class="menu-modal-title">å®Œæ•´èœå–®</h2>
        <button id="menu-modal-close" class="menu-modal-close" type="button" aria-label="é—œé–‰">&times;</button>
      </div>
      <div id="menu-modal-body" class="menu-modal-body">
        <div class="menu-loading">è¼‰å…¥ä¸­...</div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const STORAGE_KEY = 'ordering_assistant_threads_v1';
      const ACTIVE_KEY = 'ordering_assistant_active_thread_v1';

      const chatListEl = document.getElementById('chat-list');
      const chatSearchEl = document.getElementById('chat-search');
      const newChatBtn = document.getElementById('new-chat-btn');
      const exportAllBtn = document.getElementById('export-all-btn');
      const importJsonBtn = document.getElementById('import-json-btn');
      const importFileEl = document.getElementById('import-file');
      const crawlBtn = document.getElementById('crawl-btn');
      const clearBtn = document.getElementById('clear-btn');
      const helpBtn = document.getElementById('help-btn');
      const themeToggleBtn = document.getElementById('theme-toggle-btn');
      const themeIcon = document.getElementById('theme-icon');
      const chatBox = document.getElementById('chat-box');
      const chatMenuEl = document.getElementById('chat-menu');
      const toastHostEl = document.getElementById('toast-host');
      const input = document.getElementById('input');
      const sendBtn = document.getElementById('send-btn');
      const loading = document.getElementById('loading');

      let threads = [];
      let activeThreadId = null;
      let menuThreadId = null;
      let lastUndo = null;
      let searchQuery = '';

      const nowTs = () => Date.now();
      const sidFactory = () => 't_' + Math.random().toString(16).slice(2) + Date.now().toString(16);

      const escapeHtml = (s) => String(s || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

      const safeParseJSON = (text) => {
        try { return JSON.parse(text); } catch { return null; }
      };

      const relativeTime = (ts) => {
        if (!ts) return '';
        const diff = Date.now() - ts;
        const mins = Math.floor(diff / 60000);
        if (mins < 1) return 'å‰›å‰›';
        if (mins < 60) return `${mins} åˆ†é˜å‰`;
        const hrs = Math.floor(mins / 60);
        if (hrs < 24) return `${hrs} å°æ™‚å‰`;
        const days = Math.floor(hrs / 24);
        return `${days} å¤©å‰`;
      };

      const computePreview = (thread) => {
        if (!thread || !Array.isArray(thread.messages) || !thread.messages.length) return '';
        const last = thread.messages[thread.messages.length - 1];
        const t = String(last.text || '').replace(/\s+/g, ' ').trim();
        return t.length > 26 ? (t.slice(0, 26) + 'â€¦') : t;
      };

      const normalizeThread = (t) => {
        if (!t || typeof t !== 'object') return null;
        t.id = t.id || sidFactory();
        t.title = t.title || 'æ–°å°è©±';
        t.createdAt = typeof t.createdAt === 'number' ? t.createdAt : nowTs();
        t.lastUpdatedAt = typeof t.lastUpdatedAt === 'number' ? t.lastUpdatedAt : t.createdAt;
        t.pinned = Boolean(t.pinned);
        t.flags = t.flags && typeof t.flags === 'object' ? t.flags : {};
        t.sessionId = t.sessionId || sidFactory();
        t.messages = Array.isArray(t.messages) ? t.messages : [];
        return t;
      };

      const saveState = () => {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(threads));
          if (activeThreadId) localStorage.setItem(ACTIVE_KEY, activeThreadId);
        } catch (e) {
          console.warn('saveState failed', e);
        }
      };

      const loadState = () => {
        const raw = localStorage.getItem(STORAGE_KEY);
        const loaded = raw ? safeParseJSON(raw) : null;
        threads = Array.isArray(loaded) ? loaded.map(normalizeThread).filter(Boolean) : [];
        const aid = localStorage.getItem(ACTIVE_KEY);
        activeThreadId = aid || (threads[0] && threads[0].id) || null;
      };

      const getActiveThread = () => threads.find(t => t.id === activeThreadId) || null;

      const computeTitleFromFirstUserMessage = (thread) => {
        const firstUser = (thread.messages || []).find(m => m && m.role === 'user' && m.text);
        if (!firstUser) return 'æ–°å°è©±';
        const t = String(firstUser.text).trim().replace(/\s+/g, ' ');
        return t.length > 14 ? (t.slice(0, 14) + 'â€¦') : t;
      };

      const showToast = ({ message, actionText, onAction, timeoutMs = 5000 } = {}) => {
        if (!toastHostEl) return;
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.innerHTML = `
          <div class="toast-msg">${escapeHtml(message || '')}</div>
          ${actionText ? `<button type="button" class="toast-action">${escapeHtml(actionText)}</button>` : ''}
          <button type="button" class="toast-close" aria-label="é—œé–‰">Ã—</button>
        `;
        toastHostEl.appendChild(toast);

        const close = () => { if (toast && toast.parentNode) toast.parentNode.removeChild(toast); };

        const btn = toast.querySelector('.toast-action');
        if (btn) btn.addEventListener('click', () => { try { onAction && onAction(); } finally { close(); } });
        const x = toast.querySelector('.toast-close');
        if (x) x.addEventListener('click', close);
        window.setTimeout(close, timeoutMs);
      };

      const closeThreadMenu = () => {
        if (!chatMenuEl) return;
        chatMenuEl.classList.add('hidden');
        menuThreadId = null;
      };

      const openThreadMenu = ({ threadId, anchorEl, point } = {}) => {
        if (!chatMenuEl) return;
        menuThreadId = threadId;
        chatMenuEl.classList.remove('hidden');

        const rect = anchorEl ? anchorEl.getBoundingClientRect() : null;
        const x = point ? point.x : (rect ? (rect.left + 6) : 0);
        const y = point ? point.y : (rect ? (rect.bottom + 6) : 0);

        const pad = 8;
        const menuRect = chatMenuEl.getBoundingClientRect();
        let left = x;
        let top = y;
        if (left + menuRect.width + pad > window.innerWidth) left = window.innerWidth - menuRect.width - pad;
        if (top + menuRect.height + pad > window.innerHeight) top = window.innerHeight - menuRect.height - pad;
        chatMenuEl.style.left = `${Math.max(pad, left)}px`;
        chatMenuEl.style.top = `${Math.max(pad, top)}px`;
      };

      const renderChatList = () => {
        if (!chatListEl) return;
        const q = String(searchQuery || '').trim().toLowerCase();
        let list = threads.slice();

        if (q) {
          list = list.filter(t => {
            const title = String(t.title || '').toLowerCase();
            const preview = computePreview(t).toLowerCase();
            return title.includes(q) || preview.includes(q);
          });
        }

        if (!list.length) {
          chatListEl.innerHTML = `<div class="chat-list-empty">æ²’æœ‰å°è©±</div>`;
          return;
        }

        chatListEl.innerHTML = list
          .sort((a, b) => {
            if (a.pinned !== b.pinned) return a.pinned ? -1 : 1;
            return (b.lastUpdatedAt || b.createdAt || 0) - (a.lastUpdatedAt || a.createdAt || 0);
          })
          .map(t => {
            const title = t.title || 'æ–°å°è©±';
            const preview = computePreview(t);
            const timeText = relativeTime(t.lastUpdatedAt || t.createdAt);
            const active = t.id === activeThreadId;
            const pinIcon = t.pinned ? '[Pin]' : '';
            const clearedIcon = t.flags && t.flags.cleared ? '[Cleared]' : '';
            const errorIcon = t.flags && t.flags.error ? '[Error]' : '';
            const icons = [pinIcon, clearedIcon, errorIcon].filter(Boolean).join(' ');

            return `
              <div class="chat-list-row ${active ? 'active' : ''}" data-thread-id="${t.id}">
                <button class="chat-list-item" type="button" data-thread-id="${t.id}" title="åˆ‡æ›å°è©±">
                  <div class="chat-list-top">
                    <span class="chat-list-title">${escapeHtml(title)}</span>
                    <span class="chat-list-time">${escapeHtml(timeText)}</span>
                  </div>
                  <div class="chat-list-preview">
                    ${icons ? `<span class="chat-list-icons">${escapeHtml(icons)}</span>` : ''}
                    <span class="chat-list-preview-text">${escapeHtml(preview || ' ')} </span>
                  </div>
                </button>
                <button class="chat-list-more" type="button" aria-label="æ›´å¤š" title="æ›´å¤š" data-thread-more="${t.id}">â‹¯</button>
              </div>`;
          })
          .join('');

        chatListEl.querySelectorAll('[data-thread-id]').forEach(btn => {
          if (!(btn instanceof HTMLButtonElement)) return;
          if (btn.hasAttribute('data-thread-more')) return;
          btn.addEventListener('click', () => {
            const tid = btn.getAttribute('data-thread-id');
            if (!tid) return;
            switchThread(tid);
          });
        });

        chatListEl.querySelectorAll('[data-thread-more]').forEach(moreBtn => {
          moreBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const tid = moreBtn.getAttribute('data-thread-more');
            if (!tid) return;
            openThreadMenu({ threadId: tid, anchorEl: moreBtn });
          });
        });

        chatListEl.querySelectorAll('.chat-list-row').forEach(row => {
          row.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const tid = row.getAttribute('data-thread-id');
            if (!tid) return;
            openThreadMenu({ threadId: tid, point: { x: e.clientX, y: e.clientY } });
          });
        });
      };

      const exportJSON = (obj, filename) => {
        const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      const exportAllThreads = () => {
        exportJSON({ version: 1, exportedAt: nowTs(), threads }, `é»é¤åŠ©æ‰‹-å°è©±åŒ¯å‡º-${nowTs()}.json`);
        showToast({ message: 'å·²åŒ¯å‡ºå…¨éƒ¨å°è©±' });
      };

      const exportOneThread = (threadId) => {
        const t = threads.find(x => x.id === threadId);
        if (!t) return;
        exportJSON({ version: 1, exportedAt: nowTs(), thread: t }, `é»é¤åŠ©æ‰‹-å°è©±-${t.title || 'æ–°å°è©±'}.json`);
        showToast({ message: 'å·²åŒ¯å‡ºæ­¤å°è©±' });
      };

      const importThreadsFromJSON = (data) => {
        if (!data) throw new Error('JSON æ ¼å¼éŒ¯èª¤');
        const importedThreads = [];
        if (Array.isArray(data.threads)) importedThreads.push(...data.threads);
        if (data.thread) importedThreads.push(data.thread);
        if (!importedThreads.length) throw new Error('æ‰¾ä¸åˆ° threads/thread æ¬„ä½');

        const normalized = importedThreads.map(normalizeThread).filter(Boolean);
        const existingIds = new Set(threads.map(t => t.id));
        for (const t of normalized) {
          if (existingIds.has(t.id)) t.id = sidFactory();
          threads.push(t);
        }
        if (!activeThreadId && threads[0]) activeThreadId = threads[0].id;
        saveState();
        renderChatList();
        showToast({ message: `å·²åŒ¯å…¥ ${normalized.length} å€‹å°è©±` });
      };

      const deleteThread = (threadId) => {
        const idx = threads.findIndex(x => x.id === threadId);
        if (idx < 0) return;
        const removed = threads[idx];
        threads.splice(idx, 1);
        lastUndo = { type: 'delete', payload: removed, expiresAt: nowTs() + 10000 };

        if (activeThreadId === threadId) {
          activeThreadId = (threads[0] && threads[0].id) || null;
          if (!activeThreadId) createThread({ autoSwitch: true });
          redrawConversation({ keepScrollIfReading: false });
        }
        saveState();
        renderChatList();

        showToast({
          message: `å·²åˆªé™¤ã€Œ${removed.title || 'æ–°å°è©±'}ã€`,
          actionText: 'å¾©åŸ',
          onAction: () => {
            if (!lastUndo || lastUndo.type !== 'delete') return;
            if (nowTs() > lastUndo.expiresAt) return;
            threads.push(normalizeThread(lastUndo.payload));
            saveState();
            renderChatList();
          },
          timeoutMs: 9000,
        });
      };

      const togglePin = (threadId) => {
        const t = threads.find(x => x.id === threadId);
        if (!t) return;
        t.pinned = !t.pinned;
        t.lastUpdatedAt = nowTs();
        saveState();
        renderChatList();
        showToast({ message: t.pinned ? 'å·²é‡˜é¸' : 'å·²å–æ¶ˆé‡˜é¸' });
      };

      const switchThread = (threadId) => {
        const t = threads.find(x => x.id === threadId);
        if (!t) return;
        activeThreadId = threadId;
        redrawConversation();
        renderChatList();
        saveState();
        input && input.focus();
      };

      const createThread = ({ autoSwitch = true } = {}) => {
        const t = {
          id: sidFactory(),
          title: 'æ–°å°è©±',
          createdAt: Date.now(),
          lastUpdatedAt: Date.now(),
          pinned: false,
          flags: {},
          sessionId: sidFactory(),
          messages: []
        };
        threads.push(t);
        if (autoSwitch) activeThreadId = t.id;
        saveState();
        renderChatList();
        return t;
      };

      const formatText = (text) => {
        if (!text) return '';
        let html = String(text).replace(/\n/g, '<br>');
        html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        return html;
      };

      const isNearBottom = () => {
        const thresholdPx = 24;
        const distance = chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight;
        return distance <= thresholdPx;
      };

      const scrollToBottom = () => { chatBox.scrollTop = chatBox.scrollHeight; };

      const appendMessage = (role, text, { persist = true } = {}) => {
        const shouldAutoScroll = isNearBottom();
        const msgDiv = document.createElement('div');
        msgDiv.className = `message ${role}`;
        msgDiv.innerHTML = role === 'bot'
          ? `<div class="avatar">AI</div><div class="bubble">${formatText(text)}</div>`
          : `<div class="bubble">${formatText(text)}</div>`;
        chatBox.appendChild(msgDiv);
        // ç¸½æ˜¯è‡ªå‹•æ»¾å‹•åˆ°æœ€æ–°è¨Šæ¯
        setTimeout(() => scrollToBottom(), 50);

        if (persist) {
          const t = getActiveThread() || createThread({ autoSwitch: true });
          t.messages = Array.isArray(t.messages) ? t.messages : [];
          t.messages.push({ role, text });
          t.lastUpdatedAt = nowTs();
          if (role === 'user' && (!t.title || t.title === 'æ–°å°è©±')) {
            t.title = computeTitleFromFirstUserMessage(t);
          }
          saveState();
          renderChatList();
        }
      };

      const showLoading = (show) => {
        if (!loading) return;
        if (show) {
          loading.classList.remove('hidden');
          chatBox.appendChild(loading);
          if (isNearBottom()) scrollToBottom();
        } else {
          loading.classList.add('hidden');
        }
      };

      const redrawConversation = ({ keepScrollIfReading = true } = {}) => {
        if (!chatBox) return;
        const shouldAutoScroll = keepScrollIfReading ? isNearBottom() : true;

        const t = getActiveThread();
        const hasMessages = Boolean(t && Array.isArray(t.messages) && t.messages.length);

        // å§‹çµ‚é¡¯ç¤ºå°è©±æ¡†ï¼Œä¸éš±è—
        chatBox.classList.remove('hidden');

        if (!hasMessages) {
          // æ²’æœ‰è¨Šæ¯æ™‚é¡¯ç¤ºæ­¡è¿è¨Šæ¯
          chatBox.innerHTML = '';
          return;
        }

        chatBox.innerHTML = '';
        for (const m of (t.messages || [])) {
          if (!m || !m.role) continue;
          appendMessage(m.role, m.text, { persist: false });
        }

        if (shouldAutoScroll) scrollToBottom();
      };

      const ensureBasics = () => {
        if (!chatBox || !input || !sendBtn) {
          alert('å‰ç«¯å…ƒç´ ä¸å­˜åœ¨æˆ–è¼‰å…¥éŒ¯èª¤ï¼Œè«‹é‡æ–°æ•´ç†ã€‚');
          return false;
        }
        return true;
      };

      const send = async () => {
        const text = input.value.trim();
        if (!text) return;

        // æª¢æŸ¥æ˜¯å¦æ˜¯é¸æ“‡é¤å»³ï¼ˆè¼¸å…¥æ•¸å­— 1-10ï¼‰
        if (window.lastCrawledRestaurants && /^([1-9]|10)$/.test(text.trim())) {
          const idx = parseInt(text.trim()) - 1;
          if (idx >= 0 && idx < window.lastCrawledRestaurants.length) {
            const restaurant = window.lastCrawledRestaurants[idx];
            input.value = '';
            appendMessage('user', text);
            await crawlFoodpandaMenu(restaurant);
            return;
          }
        }

        if (!getActiveThread()) {
          createThread({ autoSwitch: true });
          redrawConversation({ keepScrollIfReading: false });
        }

        input.value = '';
        appendMessage('user', text);

        showLoading(true);
        input.disabled = true;

        const t = getActiveThread();
        const sessionId = (t && t.sessionId) ? t.sessionId : sidFactory();

        try {
          const res = await fetch('/api/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ sessionId, text })
          });
          const data = await res.json();
          showLoading(false);
          appendMessage('bot', data.reply || '[ç™¼ç”ŸéŒ¯èª¤] å›è¦†å…§å®¹ç‚ºç©º');
        } catch (e) {
          showLoading(false);
          const t = getActiveThread();
          if (t) {
            t.flags = t.flags && typeof t.flags === 'object' ? t.flags : {};
            t.flags.error = true;
            t.lastUpdatedAt = nowTs();
            saveState();
            renderChatList();
          }
          appendMessage('bot', `[ç™¼ç”ŸéŒ¯èª¤] ç„¡æ³•é€£ç·šï¼š${e}`);
        } finally {
          input.disabled = false;
          input.focus();
        }
      };

      const clearActiveChat = ({ notice = '' } = {}) => {
        showLoading(false);
        const t = getActiveThread();
        if (t) {
          t.messages = [];
          t.title = 'æ–°å°è©±';
          t.sessionId = sidFactory();
          t.lastUpdatedAt = nowTs();
          t.flags = t.flags && typeof t.flags === 'object' ? t.flags : {};
          t.flags.cleared = true;
          saveState();
          renderChatList();
        }

        chatBox.innerHTML = '';
        if (notice) appendMessage('bot', notice);
        input.value = '';
        input.disabled = false;
      };

      const newChat = ({ notice = 'å·²å»ºç«‹æ–°å°è©±' } = {}) => {
        showLoading(false);
        createThread({ autoSwitch: true });
        chatBox.innerHTML = '';
        if (notice) appendMessage('bot', notice);
        input.value = '';
        input.disabled = false;
        input.focus();
      };

      const showCrawlDialog = async () => {
        const query = prompt('è«‹è¼¸å…¥é¤å»³åç¨±\nä¾‹å¦‚ï¼šã€Œæ—¥å—æ‹‰é›…ã€ã€ã€Œéº¥ç•¶å‹å¤§ç”²ç¶“åœ‹ã€ã€ã€Œé¼æ³°è±ã€', '');
        if (!query || !query.trim()) return;

        showToast({ message: 'æ­£åœ¨å¾ Google æœå°‹èœå–®...', timeoutMs: 10000 });
        showLoading(true);
        input.disabled = true;

        try {
          const res = await fetch('/api/search-foodpanda', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              query: query.trim(),
              city: 'taichung',
              maxResults: 1
            })
          });
          const data = await res.json();

          if (data.success && data.restaurants && data.restaurants.length > 0) {
            // å„²å­˜é¤å»³æ¸…å–®
            window.lastCrawledRestaurants = data.restaurants;

            const restaurant = data.restaurants[0];

            // è®“ç”¨æˆ¶å¯ä»¥ç·¨è¼¯é¤å»³åç¨±
            const confirmedName = prompt(
              `æ‰¾åˆ°é¤å»³ï¼š${restaurant.name}\n\nç¢ºèªé¤å»³åç¨±æ­£ç¢ºå—ï¼Ÿ\nå¦‚æœä¸å°ï¼Œè«‹ä¿®æ”¹ï¼ˆä¾‹å¦‚ï¼šå°‡ã€Œå¤§ç”°ã€æ”¹ç‚ºã€Œå¤§ç”²ã€ï¼‰`,
              restaurant.name
            );

            if (!confirmedName || !confirmedName.trim()) {
              appendMessage('bot', 'å·²å–æ¶ˆçˆ¬å–');
              showLoading(false);
              input.disabled = false;
              input.focus();
              return;
            }

            // ä½¿ç”¨ç”¨æˆ¶ç¢ºèªçš„åç¨±
            restaurant.name = confirmedName.trim();

            appendMessage('bot', `ç¢ºèªé¤å»³ï¼š${restaurant.name}\n\næ­£åœ¨å¾ Google çŸ¥è­˜é¢æ¿çˆ¬å–å®Œæ•´èœå–®...\né€™å¯èƒ½éœ€è¦ 10-30 ç§’\nç€è¦½å™¨è¦–çª—æœƒçŸ­æš«é¡¯ç¤ºï¼ˆé¿å… Google CAPTCHAï¼‰\n\nè«‹ç¨å€™...`);

            // ç›´æ¥é–‹å§‹çˆ¬å–èœå–®
            await crawlFoodpandaMenu(restaurant);
          } else {
            appendMessage('bot', `${data.message || 'æœå°‹å¤±æ•—'}\n\nå»ºè­°ï¼š\n1. ç¢ºèªé¤å»³åç¨±æ­£ç¢º\n2. è©¦è©¦æ›´å®Œæ•´çš„åç¨±ï¼ˆä¾‹å¦‚ï¼šã€Œéº¥ç•¶å‹å¤§ç”²ç¶“åœ‹ã€ï¼‰\n3. åŒ…å«åœ°å€è³‡è¨Šï¼ˆä¾‹å¦‚ï¼šã€Œå¤§ç”²ã€è€Œéã€Œå¤§ç”°ã€ï¼‰`);
            showToast({ message: 'æœå°‹å¤±æ•—ï¼Œè«‹æŸ¥çœ‹å°è©±è¨Šæ¯' });
          }
        } catch (e) {
          appendMessage('bot', `é€£ç·šéŒ¯èª¤ï¼š${e}\n\nå¯èƒ½æ˜¯å¾Œç«¯æœå‹™æœªå•Ÿå‹•ã€‚`);
        } finally {
          showLoading(false);
          input.disabled = false;
          input.focus();
        }
      };

      const crawlFoodpandaMenu = async (restaurant) => {
        showToast({ message: `æ­£åœ¨å¾ Google çˆ¬å–ã€Œ${restaurant.name}ã€çš„èœå–®...`, timeoutMs: 60000 });
        showLoading(true);
        input.disabled = true;

        try {
          const res = await fetch('/api/crawl-foodpanda', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              vendorCode: restaurant.vendorCode,
              restaurantName: restaurant.name
            })
          });
          const data = await res.json();

          if (data.success && data.menuItems) {
            window.lastCrawledRestaurants = null;

            const restaurantInfo = data.restaurant;
            const itemCount = data.menuItems.length;

            const menuPreview = data.menuItems.slice(0, 20)
              .map((item, idx) => `${idx + 1}. ${item.dish} - ${item.price || 'åƒ¹æ ¼æœªçŸ¥'}`)
              .join('\n');

            let message = `${data.message}\n\n`;
            message += `é¤å»³ï¼š${restaurantInfo.name}\n`;
            message += `\nèœå–®ï¼ˆå‰ 20 é“ï¼‰ï¼š\n${menuPreview}`;

            if (itemCount > 20) {
              message += `\n\n...é‚„æœ‰ ${itemCount - 20} é“èœ`;
            }

            message += '\n\nèœå–®è³‡æ–™å·²å„²å­˜ï¼Œä½ å¯ä»¥é–‹å§‹è©¢å•æ¨è–¦æˆ–ç›´æ¥é»é¤ï¼';

            appendMessage('bot', message);
            showToast({ message: `æˆåŠŸçˆ¬å– ${itemCount} é“èœå“ï¼` });
          } else {
            appendMessage('bot', `${data.message}\n\næç¤ºï¼š\n1. ç¢ºèªé¤å»³åç¨±æ­£ç¢º\n2. ç¢ºèª Google ä¸Šæœ‰æ­¤é¤å»³çš„èœå–®è³‡æ–™\n3. è©¦è©¦æœå°‹ã€Œé¤å»³åç¨± + åˆ†åº—ã€ï¼ˆä¾‹å¦‚ï¼šã€Œæ—¥å—æ‹‰é›…ã€ï¼‰`);
            showToast({ message: 'çˆ¬å–å¤±æ•—ï¼Œè«‹æŸ¥çœ‹å°è©±è¨Šæ¯' });
          }
        } catch (e) {
          appendMessage('bot', `é€£ç·šéŒ¯èª¤ï¼š${e}\n\nè«‹ç¢ºèªå¾Œç«¯æœå‹™æ­£å¸¸é‹ä½œã€‚`);
        } finally {
          showLoading(false);
          input.disabled = false;
          input.focus();
        }
      };

      const handleHelp = () => {
        appendMessage('bot', 'ä½ å¯ä»¥ç›´æ¥è¼¸å…¥æƒ³é»çš„é¤é»ï¼šä¾‹å¦‚ã€Œé›æ’é£¯ 1 ä»½ã€ç´…èŒ¶ 2 æ¯ã€ã€‚æˆ‘æœƒå¹«ä½ æ•´ç†èˆ‡ç¢ºèªã€‚\n\nå°æŠ€å·§ï¼šé»æ“Šä¸Šæ–¹ã€Œçˆ¬èœå–®ã€å¯ä»¥å¾ Google Maps æœå°‹é¤å»³è³‡è¨Šï¼ˆä½†ä¸æ˜¯æ‰€æœ‰é¤å»³éƒ½æœ‰ç·šä¸Šèœå–®è³‡æ–™ï¼‰ã€‚');
      };

      const showRename = (threadId) => {
        const t = threads.find(x => x.id === threadId);
        if (!t) return;
        const name = prompt('é‡æ–°å‘½åå°è©±', t.title || 'æ–°å°è©±');
        if (name === null) return;
        t.title = (name || 'æ–°å°è©±').trim();
        t.lastUpdatedAt = nowTs();
        saveState();
        renderChatList();
      };

      if (!ensureBasics()) return;

      loadState();
      if (!threads.length) createThread({ autoSwitch: true });
      if (!getActiveThread() && threads[0]) activeThreadId = threads[0].id;
      renderChatList();
      redrawConversation({ keepScrollIfReading: false });

      sendBtn?.addEventListener('click', send);
      input?.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          send();
        }
      });

      chatSearchEl?.addEventListener('input', () => {
        searchQuery = chatSearchEl.value || '';
        renderChatList();
      });

      exportAllBtn?.addEventListener('click', exportAllThreads);
      if (importJsonBtn && importFileEl) {
        importJsonBtn.addEventListener('click', () => importFileEl.click());
        importFileEl.addEventListener('change', async () => {
          const f = importFileEl.files && importFileEl.files[0];
          if (!f) return;
          try {
            const text = await f.text();
            const data = safeParseJSON(text);
            importThreadsFromJSON(data);
          } catch (e) {
            showToast({ message: `åŒ¯å…¥å¤±æ•—ï¼š${e}` });
          } finally {
            importFileEl.value = '';
          }
        });
      }

      chatMenuEl?.querySelectorAll('[data-action]')?.forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.getAttribute('data-action');
          const tid = menuThreadId;
          closeThreadMenu();
          if (!tid) return;
          if (action === 'rename') return showRename(tid);
          if (action === 'pin') return togglePin(tid);
          if (action === 'export') return exportOneThread(tid);
          if (action === 'delete') return deleteThread(tid);
        });
      });

      window.addEventListener('click', (e) => {
        if (!chatMenuEl || chatMenuEl.classList.contains('hidden')) return;
        if (e.target === chatMenuEl || chatMenuEl.contains(e.target)) return;
        closeThreadMenu();
      });
      window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeThreadMenu(); });
      window.addEventListener('resize', closeThreadMenu);
      window.addEventListener('scroll', () => closeThreadMenu(), true);
      chatListEl?.addEventListener('scroll', () => closeThreadMenu(), { passive: true });

      newChatBtn?.addEventListener('click', () => newChat({ notice: 'å·²å»ºç«‹æ–°å°è©±' }));
      crawlBtn?.addEventListener('click', showCrawlDialog);
      clearBtn?.addEventListener('click', () => clearActiveChat({ notice: 'å·²æ¸…ç©ºï¼Œç›®å‰æ˜¯æ–°å°è©±ã€‚' }));
      helpBtn?.addEventListener('click', handleHelp);

      // é¤å»³ç®¡ç†åŠŸèƒ½
      const restaurantSelect = document.getElementById('restaurant-select');
      const restaurantSelectMobile = document.getElementById('restaurant-select-mobile');
      const restaurantInfo = document.getElementById('restaurant-info');

      async function loadRestaurants() {
        try {
          const response = await fetch('/api/restaurants');
          const data = await response.json();

          // æ¸…ç©ºå…©å€‹é¸æ“‡å™¨
          restaurantSelect.innerHTML = '';
          if (restaurantSelectMobile) {
            restaurantSelectMobile.innerHTML = '';
          }

          if (!data.restaurants || data.restaurants.length === 0) {
            restaurantSelect.innerHTML = '<option>ç„¡å¯ç”¨é¤å»³</option>';
            if (restaurantSelectMobile) {
              restaurantSelectMobile.innerHTML = '<option>ç„¡é¤å»³</option>';
            }
            restaurantInfo.textContent = 'å°šæœªçˆ¬å–ä»»ä½•é¤å»³èœå–®';
            restaurantInfo.style.background = '#fef2f2';
            restaurantInfo.style.color = '#991b1b';
            return;
          }

          // å¡«å……å…©å€‹é¸æ“‡å™¨
          data.restaurants.forEach(r => {
            // å´é‚Šæ¬„é¸æ“‡å™¨ï¼ˆé›»è…¦ç‰ˆï¼‰
            const opt = document.createElement('option');
            opt.value = r.name;
            opt.textContent = `${r.name} (${r.itemCount}é …)`;
            if (r.active) opt.selected = true;
            restaurantSelect.appendChild(opt);

            // æ‰‹æ©Ÿç‰ˆé¸æ“‡å™¨
            if (restaurantSelectMobile) {
              const optMobile = document.createElement('option');
              optMobile.value = r.name;
              optMobile.textContent = r.name;
              if (r.active) optMobile.selected = true;
              restaurantSelectMobile.appendChild(optMobile);
            }
          });

          // æ›´æ–°è³‡è¨Šé¡¯ç¤º
          const active = data.restaurants.find(r => r.active);
          if (active) {
            restaurantInfo.textContent = `ç•¶å‰ä½¿ç”¨ ${active.name} çš„èœå–® (å…± ${active.itemCount} é …èœå“)`;
            restaurantInfo.style.background = '#f0fdf4';
            restaurantInfo.style.color = '#166534';
          }

          console.log('å·²è¼‰å…¥é¤å»³åˆ—è¡¨:', data.restaurants.length);
        } catch (err) {
          console.error('è¼‰å…¥é¤å»³åˆ—è¡¨å¤±æ•—:', err);
          restaurantSelect.innerHTML = '<option>è¼‰å…¥å¤±æ•—</option>';
          if (restaurantSelectMobile) {
            restaurantSelectMobile.innerHTML = '<option>è¼‰å…¥å¤±æ•—</option>';
          }
          restaurantInfo.textContent = 'ç„¡æ³•é€£æ¥åˆ°å¾Œç«¯æœå‹™';
          restaurantInfo.style.background = '#fef2f2';
          restaurantInfo.style.color = '#991b1b';
        }
      }

      async function switchRestaurant(name) {
        try {
          const response = await fetch(`/api/switch-restaurant?restaurant_name=${encodeURIComponent(name)}`, {
            method: 'POST'
          });
          const data = await response.json();

          if (data.success) {
            showToast(`${data.message}`, 2000);
            loadRestaurants(); // é‡æ–°è¼‰å…¥æ›´æ–°è³‡è¨Š
          } else {
            showToast(`åˆ‡æ›å¤±æ•—: ${data.message}`, 3000);
          }
        } catch (err) {
          console.error('åˆ‡æ›é¤å»³å¤±æ•—:', err);
          showToast('åˆ‡æ›é¤å»³æ™‚ç™¼ç”ŸéŒ¯èª¤', 3000);
        }
      }

      // é›»è…¦ç‰ˆé¸æ“‡å™¨äº‹ä»¶
      restaurantSelect?.addEventListener('change', (e) => {
        const selectedName = e.target.value;
        if (selectedName && selectedName !== 'è¼‰å…¥ä¸­...' && selectedName !== 'ç„¡å¯ç”¨é¤å»³') {
          switchRestaurant(selectedName);
        }
      });

      // æ‰‹æ©Ÿç‰ˆé¸æ“‡å™¨äº‹ä»¶
      restaurantSelectMobile?.addEventListener('change', (e) => {
        const selectedName = e.target.value;
        if (selectedName && selectedName !== 'è¼‰å…¥ä¸­...' && selectedName !== 'ç„¡é¤å»³') {
          switchRestaurant(selectedName);
        }
      });

      // åˆªé™¤é¤å»³åŠŸèƒ½
      const deleteRestaurantBtn = document.getElementById('delete-restaurant-btn');

      async function deleteRestaurant(name) {
        if (!confirm(`ç¢ºå®šè¦åˆªé™¤ã€Œ${name}ã€çš„èœå–®å—ï¼Ÿ\n\næ­¤æ“ä½œå°‡æœƒï¼š\n1. å¾ç³»çµ±ä¸­ç§»é™¤æ­¤é¤å»³\n2. åˆªé™¤å°æ‡‰çš„ JSON æª”æ¡ˆ\n\næ­¤æ“ä½œç„¡æ³•å¾©åŸï¼`)) {
          return;
        }

        try {
          const response = await fetch(`/api/menu/${encodeURIComponent(name)}`, {
            method: 'DELETE'
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ message: 'æœªçŸ¥éŒ¯èª¤' }));
            throw new Error(errorData.message || errorData.detail || 'åˆªé™¤å¤±æ•—');
          }

          const data = await response.json();

          if (data.success) {
            showToast({ message: `å·²åˆªé™¤ã€Œ${name}ã€`, timeoutMs: 3000 });
            // é‡æ–°è¼‰å…¥é¤å»³åˆ—è¡¨
            await loadRestaurants();
          } else {
            showToast({ message: `åˆªé™¤å¤±æ•—: ${data.message}`, timeoutMs: 3000 });
          }
        } catch (err) {
          console.error('åˆªé™¤é¤å»³å¤±æ•—:', err);
          showToast({ message: `åˆªé™¤æ™‚ç™¼ç”ŸéŒ¯èª¤: ${err.message}`, timeoutMs: 3000 });
        }
      }

      // åˆªé™¤æŒ‰éˆ•äº‹ä»¶
      deleteRestaurantBtn?.addEventListener('click', () => {
        const selectedName = restaurantSelect?.value;
        if (selectedName && selectedName !== 'è¼‰å…¥ä¸­...' && selectedName !== 'ç„¡å¯ç”¨é¤å»³' && selectedName !== 'è¼‰å…¥å¤±æ•—') {
          deleteRestaurant(selectedName);
        } else {
          showToast({ message: 'è«‹å…ˆé¸æ“‡ä¸€å€‹é¤å»³', timeoutMs: 2000 });
        }
      });

      // æ·±è‰²æ¨¡å¼åˆ‡æ›
      const htmlElement = document.documentElement;

      // å¾ localStorage è®€å–ä¸»é¡Œè¨­å®š
      const savedTheme = localStorage.getItem('theme') || 'light';
      htmlElement.setAttribute('data-theme', savedTheme);
      if (themeIcon) {
        themeIcon.textContent = savedTheme === 'dark' ? 'æ·ºè‰²æ¨¡å¼' : 'æ·±è‰²æ¨¡å¼';
      }

      themeToggleBtn?.addEventListener('click', () => {
        const currentTheme = htmlElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

        htmlElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);
        if (themeIcon) {
          themeIcon.textContent = newTheme === 'dark' ? 'æ·ºè‰²æ¨¡å¼' : 'æ·±è‰²æ¨¡å¼';
        }

        showToast({
          message: newTheme === 'dark' ? 'å·²åˆ‡æ›è‡³æ·±è‰²æ¨¡å¼' : 'å·²åˆ‡æ›è‡³æ·ºè‰²æ¨¡å¼',
          duration: 1500
        });
      });

      // é é¢è¼‰å…¥æ™‚åŸ·è¡Œ
      loadRestaurants();

      // ============================================
      // æŸ¥çœ‹å®Œæ•´èœå–®åŠŸèƒ½
      // ============================================
      const viewMenuBtn = document.getElementById('view-menu-btn');
      const menuModal = document.getElementById('menu-modal');
      const menuModalClose = document.getElementById('menu-modal-close');
      const menuModalOverlay = menuModal?.querySelector('.menu-modal-overlay');
      const menuModalBody = document.getElementById('menu-modal-body');
      const menuModalTitle = document.getElementById('menu-modal-title');

      // æ‰“é–‹ Modal
      async function openMenuModal() {
        if (!menuModal || !menuModalBody) return;

        menuModal.classList.remove('hidden');
        menuModalBody.innerHTML = '<div class="menu-loading">è¼‰å…¥ä¸­...</div>';

        try {
          const response = await fetch('/api/current-menu');
          const data = await response.json();

          if (!data.success) {
            menuModalBody.innerHTML = `<div class="menu-error">${escapeHtml(data.message || 'è¼‰å…¥å¤±æ•—')}</div>`;
            return;
          }

          // æ›´æ–°æ¨™é¡Œ
          if (menuModalTitle && data.restaurantName) {
            menuModalTitle.textContent = `${data.restaurantName} - å®Œæ•´èœå–®`;
          }

          // æ¸²æŸ“èœå–®
          if (!data.categories || data.categories.length === 0) {
            menuModalBody.innerHTML = '<div class="menu-empty">ç›®å‰æ²’æœ‰èœå–®è³‡æ–™</div>';
            return;
          }

          let html = '';
          for (const category of data.categories) {
            const items = category.items || [];
            if (items.length === 0) continue;

            html += `
              <div class="menu-category">
                <h3 class="menu-category-title">${escapeHtml(category.name)}</h3>
                <div class="menu-items">
            `;

            for (const item of items) {
              const name = escapeHtml(item.name || 'æœªå‘½å');
              const price = item.price ? `$${item.price}` : 'æ™‚åƒ¹';
              html += `
                <div class="menu-item">
                  <span class="menu-item-name">${name}</span>
                  <span class="menu-item-price">${escapeHtml(price)}</span>
                </div>
              `;
            }

            html += `
                </div>
              </div>
            `;
          }

          menuModalBody.innerHTML = html;

        } catch (error) {
          console.error('è¼‰å…¥èœå–®å¤±æ•—:', error);
          menuModalBody.innerHTML = '<div class="menu-error">è¼‰å…¥èœå–®æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦</div>';
        }
      }

      // é—œé–‰ Modal
      function closeMenuModal() {
        if (!menuModal) return;
        menuModal.classList.add('hidden');
      }

      // äº‹ä»¶ç›£è½
      viewMenuBtn?.addEventListener('click', openMenuModal);
      menuModalClose?.addEventListener('click', closeMenuModal);

      // é»æ“Šé®ç½©å±¤é—œé–‰
      menuModalOverlay?.addEventListener('click', closeMenuModal);

      // ESC éµé—œé–‰
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && menuModal && !menuModal.classList.contains('hidden')) {
          closeMenuModal();
        }
      });

      console.info('[é»é¤åŠ©æ‰‹] UI ready');
    })();
  </script>
</body>

</html>